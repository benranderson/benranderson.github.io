<!DOCTYPE html>
<html lang="en">

<head>
    <title>Rendering Matplotlib plots on load-balanced Streamlit servers - Ben Randerson
</title>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="generator" content="Pelican v" />
<meta name="author" content="Ben Randerson">

<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
<link rel="icon" type="image/x-icon" href="/favicon.ico" />
<link rel="stylesheet" type="text/css" href="/theme/css/style.css" />
<link rel="stylesheet" type="text/css" href="/theme/css/pygment.css" />

<!-- theme colors (safari only) -->
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#fff" />
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#171717" />

<link rel="canonical" href="https://benranderson.github.io/blog/streamlit-matplotlib.html" />

<meta property="og:title" content="Rendering Matplotlib plots on load-balanced Streamlit servers" />
<meta property="og:url" content="https://benranderson.github.io/blog/streamlit-matplotlib.html" />

<meta name="description" content="The Problem When running Streamlit applications on load-balanced servers with multiple stateless backend containers, Matplotlib plots may fail to render. For example, this code... import streamlit as st fig = generate_matplotlib_fig() st.pyplot(fig) ...can produce this less than useful output: This is because Matplotlib plots depend on temporary files saved …" />
<meta property="og:description" content="The Problem When running Streamlit applications on load-balanced servers with multiple stateless backend containers, Matplotlib plots may fail to render. For example, this code... import streamlit as st fig = generate_matplotlib_fig() st.pyplot(fig) ...can produce this less than useful output: This is because Matplotlib plots depend on temporary files saved …" />

<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "headline": "Rendering Matplotlib plots on load-balanced Streamlit servers",
    "url": "https://benranderson.github.io/blog/streamlit-matplotlib.html",
    "description": "The Problem When running Streamlit applications on load-balanced servers with multiple stateless backend containers, Matplotlib plots may fail to render. For example, this code... import streamlit as st fig = generate_matplotlib_fig() st.pyplot(fig) ...can produce this less than useful output: This is because Matplotlib plots depend on temporary files saved …",
    "author": {
      "@type": "Person",
      "name": "Ben Randerson",
      "url": "https://benranderson.github.io"
    },
    "publisher": {
      "@type": "Person",
      "name": "Ben Randerson"
    },
    "datePublished": "2025-11-23T00:00:00+00:00",
    "dateModified": "2025-11-23T00:00:00+00:00"
  }
</script>

</head>

<body>
    <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle theme">
        <svg class="theme-toggle-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
            stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <!-- Moon icon (default) -->
            <path class="moon-icon" d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
            <!-- Sun icon (hidden by default) -->
            <g class="sun-icon" style="display: none;">
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
            </g>
        </svg>
    </button>
    <header class="container nu ">
        <h1><a class="sitename" href="/">Ben Randerson</a></h1>
        <div>
            <a href="/" >Blog</a> |
            <a href="/about.html" >About</a>
            |
            <a href="/projects.html" >Projects</a> |
            <a target="_blank" href="cv.pdf">CV</a>
        </div>
    </header>
    <script src="/theme/js/theme-toggle.js"></script>
    <div class="container vertical-spacing no-top main-content">
<h1>Rendering Matplotlib plots on load-balanced Streamlit servers</h1>
<h2>The Problem</h2>
<p>When running Streamlit applications on load-balanced servers with multiple stateless backend containers, Matplotlib plots may fail to render.</p>
<p>For example, this code...</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">streamlit</span> <span class="k">as</span> <span class="nn">st</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">generate_matplotlib_fig</span><span class="p">()</span>
<span class="n">st</span><span class="o">.</span><span class="n">pyplot</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
</code></pre></div>

<p>...can produce this less than useful output:</p>
<p><img src="https://benranderson.github.io/images/render-fail.png" alt="render-fail" width="400"></p>
<p>This is because Matplotlib plots depend on temporary files saved to the filesystem, and requests routed to different containers may not find the image files created by other containers. Each container has its own ephemeral filesystem with no shared storage between them.</p>
<h2>The Fix</h2>
<p>This fix converts Matplotlib plots to base64-encoded images embedded directly in the HTML instead of saving them as separate files. It ensures that when the server's load balancer routes requests to different backend containers, the image data travels with the page response rather than requiring a separate file lookup that might hit a different container that doesn't have the file.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">base64</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">BytesIO</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">streamlit</span> <span class="k">as</span> <span class="nn">st</span>


<span class="k">def</span> <span class="nf">fig_to_html</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a Matplotlib figure to base64-encoded HTML img tag.</span>

<span class="sd">    Necessary to avoid issues with load-balanced production servers where containers</span>
<span class="sd">    don&#39;t share a filesystem.</span>

<span class="sd">    Args:</span>
<span class="sd">        fig: Matplotlib figure object</span>
<span class="sd">        dpi: Dots per inch for the output image (default 100 for web display)</span>

<span class="sd">    Returns:</span>
<span class="sd">        HTML img tag with base64-encoded image data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">BytesIO</span><span class="p">()</span> <span class="k">as</span> <span class="n">buf</span><span class="p">:</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;png&quot;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s2">&quot;tight&quot;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>
        <span class="c1"># close figure to free memory</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="n">buf</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">img_base64</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64encode</span><span class="p">(</span><span class="n">buf</span><span class="o">.</span><span class="n">read</span><span class="p">())</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
    <span class="n">img_data_uri</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;data:image/png;base64,</span><span class="si">{</span><span class="n">img_base64</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;img src=&quot;</span><span class="si">{</span><span class="n">img_data_uri</span><span class="si">}</span><span class="s1">&quot; style=&quot;max-width: 100%; height: auto;&quot;&gt;&#39;</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">generate_matplotlib_fig</span><span class="p">()</span>
<span class="n">st</span><span class="o">.</span><span class="n">markdown</span><span class="p">(</span><span class="n">fig_to_html</span><span class="p">(</span><span class="n">fig</span><span class="p">),</span> <span class="n">unsafe_allow_html</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

<p>As a bonus, this should make plot rendering faster than the original <code>st.pyplot()</code> approach for typical plot sizes.</p>
<p>This is because the image data is embedded directly in the HTML response, requiring only one HTTP request/response cycle. In contrast, <code>st.pyplot()</code> saves the plot to a temporary file, sends HTML with an image reference, and then the browser makes a second HTTP request to fetch the image.</p>
<p>By removing this round-trip (and the filesystem I/O overhead) the base64 approach can be faster, especially on networks with higher latency.</p>
<h2>Alternative Solutions</h2>
<p>While the base64 encoding approach above is the most portable solution, there are other ways to solve this problem:</p>
<ol>
<li><strong>Shared storage</strong>: Configure persistent volumes that all containers can access</li>
<li><strong>Object storage</strong>: Save plots to S3/blob storage and serve them via signed URLs</li>
<li><strong>"Sticky" sessions</strong>: Configure the load balancer to route users to the same container (not recommended as it reduces load balancing effectiveness)</li>
</ol>
<h2>What Didn't Work</h2>
<p>An earlier attempt to fix this involved converting the figure to a bytes buffer and passing that directly to Streamlit's <code>st.image()</code>, as shown below.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># this doesn&#39;t work as Streamlit still saves images to temp files on disk</span>
<span class="k">def</span> <span class="nf">fig_to_buf</span><span class="p">(</span><span class="n">fig</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a Matplotlib figure to an image bytes buffer.&quot;&quot;&quot;</span>
    <span class="n">buf</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">()</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;png&quot;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s2">&quot;tight&quot;</span><span class="p">)</span>
    <span class="c1"># close figure to free memory</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
    <span class="n">buf</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">buf</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">generate_matplotlib_fig</span><span class="p">()</span> 
<span class="n">st</span><span class="o">.</span><span class="n">image</span><span class="p">(</span><span class="n">fig_to_buf</span><span class="p">(</span><span class="n">fig</span><span class="p">))</span>
</code></pre></div>

<p>However, this didn't work as Streamlit still stores the buffer contents to a temporary file on disk before serving it as an image via <code>st.image()</code>, and so the original problem remained.</p>
<br>
<div style="display: flex; justify-content: space-between; align-items: center">
    <i class="greyed-out">November 23, 2025</i>
    <div>
        <a href="mailto:ben.m.randerson@gmail.com?subject=Rendering%20Matplotlib%20plots%20on%20load-balanced%20Streamlit%20servers">Reply</a>
    </div>
</div>
    </div>
    <footer class="container nu no-top">
<center>
    <a href="mailto:ben.m.randerson@gmail.com" target="_blank" rel="noopener">Email</a> |     <a href="https://linkedin.com/in/ben-randerson" target="_blank" rel="noopener">LinkedIn</a> |     <a href="https://github.com/benranderson" target="_blank" rel="noopener">GitHub</a></center>    </footer>
</body>

</html>